#+STARTUP: content

* Emacs Config

This is my Emacs config. [[https://github.com/hrs/dotfiles/blob/master/emacs/.emacs.d/configuration.org][There]] [[https://jamiecollinson.com/blog/my-emacs-config/][are]] [[https://pages.sachachua.com/.emacs.d/Sacha.html][many]] [[https://github.com/wasamasa/dotemacs/blob/master/init.org][like]] [[https://github.com/larstvei/dot-emacs][it]], but this one is
mine. My Emacs config is my best friend. It is my life.

** Quick Settings

I leave some settings near the top. It's quick to access which makes
these settings easy to change.

#+BEGIN_SRC emacs-lisp
  (defconst lia-use-tabs nil
    "When non-nil, indentation uses tab characters instead of spaces.")

  (defconst lia-indent-width 2
    "Default indentation width.")

  (defconst lia-display-font "Iosevka 10"
    "Set the font.")

  (defconst lia-theme 'doom-one
    "Emacs theme to use.")

  (defconst lia-use-line-numbers nil
    "When non-nil, show line numbers when programming.")
#+END_SRC

** Early Initialization

Below are some things that speed up startup and hides things that I
don't want to see during startup.

*** Avoid Garbage Collection

Cleaning up garbage takes time. Try to avoid garbage
collection as much as possible.

Near the end of the config, the memory threshold is set to a
reasonable value.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 402653184
        gc-cons-percentage 0.6)
#+END_SRC

*** Unset =file-name-handler-alist=

Emacs goes through this list when files are opened. Disable it during
startup.

=file-name-handler-alist= should be set back to its original value
near the end of initialization.

#+BEGIN_SRC emacs-lisp
  (defvar lia--file-name-handler-alist file-name-handler-alist)
  (setq file-name-handler-alist nil)
#+END_SRC

*** Hide Irrelevant Messages

Be quiet at startup; don't load or display anything unnecessary.

shamelessly stolen from [[https://github.com/hlissner/doom-emacs/blob/5dacbb7cb1c6ac246a9ccd15e6c4290def67757c/core/core.el#L112][doom-emacs's core]].

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message user-login-name
        inhibit-default-init t
        initial-major-mode 'fundamental-mode
        initial-scratch-message nil
        mode-line-format nil)
#+END_SRC

*** Hide Those Disgusting Bars

The GUI elements are ugly and I don't use them.

#+BEGIN_SRC emacs-lisp
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
  (tool-bar-mode -1)
#+END_SRC

** Package Setup

Activate Emacs packages.

Unset =package-enable-at-startup= for a startup time boost.

#+BEGIN_SRC emacs-lisp
  (require 'package)
  (setq package-enable-at-startup nil)
  (package-initialize)
#+END_SRC

*** Package Sources

Setup =package-archives= to download packages from MELPA and GNU ELPA

#+BEGIN_SRC emacs-lisp
  (setq package-archives '(("melpa" . "http://melpa.org/packages/")
                           ("gnu" . "http://elpa.gnu.org/packages/")))
#+END_SRC

If elpa.gnu.org is down. try the mirror on GitHub:

# use 'lisp' to avoid evaluation

#+BEGIN_SRC lisp
  ("gnu" . "https://raw.githubusercontent.com/d12frosted/elpa-mirror/master/gnu/")
#+END_SRC

*** Bootstrap =use-package=

Use =use-package=. Install it if it's not installed.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile (require 'use-package))
#+END_SRC

** Custom File

Stop littering my =init.el=. Put emacs customize stuff in a separate
file.

Create the custom file if it doesn't exist.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))

  (unless (file-exists-p custom-file)
    (write-region "" nil custom-file))

  (load custom-file nil t)
#+END_SRC

** Appearance

Emacs looks awful by itself. It needs help getting all dolled up.

*** At DOOM's Gate

=doom-themes= is a pack of gorgeous themes for Emacs. I'm using it
alongside =doom-modeline= which is a super fancy modeline full of
features (state indicator, git branch, error count, icons, etc).

#+BEGIN_SRC emacs-lisp
  (use-package doom-themes
    :ensure t
    :config
    (load-theme lia-theme t))

  (use-package doom-modeline
    :ensure t
    :hook (after-init . doom-modeline-mode)
    :init
    (setq doom-modeline-height 35
          doom-modeline-buffer-file-name-style 'buffer-name))
#+END_SRC

*** Style The Fringe

The fringe is the space by the left and right of the window. I want
the colour of the fringe to be the same as the background colour.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'fringe nil :background nil)
#+END_SRC

*** Parenthesis

Make it easy to spot matching brackets =[]= ={}= and parenthesis =()=
with rainbow delimiters.

#+BEGIN_SRC emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

Highlight the matching parenthesis under point.

#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
#+END_SRC

*** Visualize Whitespace

Show tab characters and trailing whitespace.

Space characters are not shown. Spaces are everywhere. I think that
having visible space characters is cluttered and it makes text hard to
read.

On the other hand, tab characters appear much less often. I want to
see tabs so that I'm aware of the indentation style. This also allows
me to see if indentation is consistent, or if it's mixed tabs and
spaces.

To keep files nice and neat, mark trailing whitespace with an
obnoxious red colour.

#+BEGIN_SRC emacs-lisp
  (setq-default whitespace-style '(face tabs tab-mark trailing))
#+END_SRC

Enable whitespace visualization everywhere.

#+BEGIN_SRC emacs-lisp
  (global-whitespace-mode)
#+END_SRC

*** Line numbers

When programming, display line numbers on the left side of the buffer.

Set the minimum number of columns that line numbers take up.

#+BEGIN_SRC emacs-lisp
  (setq-default display-line-numbers-width 3
                display-line-numbers-widen t)
#+END_SRC

Set =lia-use-line-numbers= to a non-nil value to enable line numbers.

#+BEGIN_SRC emacs-lisp
  (when lia-use-line-numbers
    (add-hook 'prog-mode-hook 'display-line-numbers-mode))
#+END_SRC

*** Font

Set the font. Change with =lia-display-font=.

#+BEGIN_SRC emacs-lisp
  (set-frame-font lia-display-font nil t)
#+END_SRC

*** Blinking cursor

Disable cursor blink. I have no idea why the blinking bugs me so much,
but it does.

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode -1)
#+END_SRC

** Keybinding with General

Use General. A package that makes binding keys easy and convenient.

#+BEGIN_SRC emacs-lisp
  (use-package general
    :ensure t
    :config
    ;; open current file externally in dired
    (general-define-key
     :keymaps 'dired-mode-map
     "C-c C-o" 'lia/open)

    ;; global keybindings
    (general-define-key
     "C-\\" 'lia/join-line
     "C-c r" 'revert-buffer
     "C-c RET" 'lia/new-tmux-window-and-launch-scratchpad
     "C-c SPC" 'lia/open-file-explorer
     "M-n" (lambda () (interactive) (scroll-up-command 1))
     "M-p" (lambda () (interactive) (scroll-down-command 1))
     "C-M-n" (lambda () (interactive) (scroll-up-command (/ (window-height) 2)))
     "C-M-p" (lambda () (interactive) (scroll-down-command (/ (window-height) 2)))
     [remap forward-word] 'forward-to-word
     [remap backward-word] 'backward-to-word
     [remap delete-indentation] 'lia/join-line
     [remap delete-other-windows] 'lia/toggle-other-windows))
#+END_SRC

** Ivy

I used to use Helm but mainly used it for simple things. All of the
things that I've done in Helm, I can do in Ivy. Since Helm has a
larger footprint, I've abandoned it for Ivy.

=ivy-alt-done= is just like pressing enter, except when there's a
directory, it will autocomplete with the selected candidate.

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :ensure t
    :hook (after-init . ivy-mode)
    :general
    (ivy-minibuffer-map
     "TAB" 'ivy-alt-done)
    :init
    ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
    (setq ivy-use-virtual-buffers t)
    ;; number of result lines to display
    (setq ivy-height 15)
    ;; does not count candidates
    (setq ivy-count-format "")
    ;; no regexp by default
    (setq ivy-initial-inputs-alist nil))
#+END_SRC

Remap common Emacs functions with ones that use Ivy for completion.

Replace search with =counsel-grep-or-swiper=.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :ensure t
    :after ivy
    :general
    ("C-s" 'counsel-grep-or-swiper
     "C-r" 'counsel-grep-or-swiper-backward)
    :config
    (counsel-mode))
#+END_SRC

Swiper provides ways to find text really really quickly.

The =swiper= command is a great replacement for default search. It
shows multiple results in the minibuffer. =swiper-all= runs a search
through all buffers.

#+BEGIN_SRC emacs-lisp
  (use-package swiper
    :ensure t
    :after ivy)
#+END_SRC

** Editor

Below are some behaviours that I want from Emacs.

*** Code completion

Yasnippet integrates with Company. Show snippets in candidate list by
adding the Yasnippet backend.

#+BEGIN_SRC emacs-lisp
  (defun lia--company-mode/backend-with-yas (backend)
    (if (and (listp backend) (member 'company-yasnippet backend))
        backend
      (append (if (consp backend) backend (list backend))
              '(:with company-yasnippet))))
#+END_SRC

Company enables text and code completions when typing by showing a
list of candidates to auto-complete.

#+BEGIN_SRC emacs-lisp
  (use-package company
    :ensure t
    :hook (prog-mode . company-mode)
    :general
    (company-active-map
     "C-c C-j" 'yas-expand)
    :init
    ;; don't delay autocomplete suggesstions
    (setq company-idle-delay 0)
    ;; popup completions after typing a single character
    (setq company-minimum-prefix-length 1)
    ;; don't lowercase candidates
    (setq company-dabbrev-downcase nil)
    :config
    ;; enable yasnippet backend
    (setq company-backends
          (mapcar #'lia--company-mode/backend-with-yas company-backends)))
#+END_SRC

*** Automatically Switch Indentation Style

I really like how VS Code (and probably other editors such as Atom)
changes the indentation style of the editor to fit the file currently
open.

If only there was a way to do this in Em-- Oh look! there's a package
that does exactly this!

#+BEGIN_SRC emacs-lisp
  (use-package dtrt-indent
    :ensure t
    :hook (prog-mode . dtrt-indent-mode))
#+END_SRC

*** Switch Windows Quickly

=ace-window= shows a label for each window. Pressing the character in
a label will jump to the labeled window.

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :ensure t
    :commands (ace-window)
    :general
    ("M-o" 'ace-window))
#+END_SRC

*** =avy= Makes You Feel Like a Sniper

Jump to a part of the visible buffer.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :ensure t
    :commands (avy-goto-char)
    :general
    (:keymaps
     'override
     "C-'" 'avy-goto-char-timer))
#+END_SRC

*** Jump To Definition

Dumb Jump adds "Jump to definition" behaviour without generating
CTAGS. It's definitely slower than CTAGS, but Dumb Jump needs no
configuration.

#+BEGIN_SRC emacs-lisp
  (use-package dumb-jump
    :ensure nil
    :commands (dumb-jump-go))
#+END_SRC

*** Emmet

Emmet is a must-have for web devs. Type emmet abbreviations, hit =C-j=, and
HTML comes out!

The following:

#+BEGIN_EXAMPLE
ul#foods>li.food-item*5
#+END_EXAMPLE

Expands to:

#+BEGIN_SRC html
  <ul id="foods">
    <li class="food-item"></li>
    <li class="food-item"></li>
    <li class="food-item"></li>
    <li class="food-item"></li>
    <li class="food-item"></li>
  </ul>
#+END_SRC

Enable Emmet support. It adds =C-j= as a keybinding for expanding
Emmet abbreviations.

#+BEGIN_SRC emacs-lisp
  (use-package emmet-mode
    :ensure t
    :hook ((sgml-mode . emmet-mode)
           (css-mode . emmet-mode)
           (rjsx-mode . emmet-mode)
           (web-mode . emmet-mode)))
#+END_SRC

*** Get =$PATH=

Get the =$PATH= from the shell. This lets me use Flycheck with ESLint,
as well as use several programs that auto-format code.

Doesn't work on Windows.

#+BEGIN_SRC emacs-lisp
  (use-package exec-path-from-shell
    :ensure t
    :defer 1
    :init
    (setq exec-path-from-shell-check-startup-files nil
          exec-path-from-shell-shell-name "/bin/bash")
    :config
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+END_SRC

*** Expand Region

Highlight a region of code quickly and easily. This is useful with
Emacs Lisp and Clojure where it's trivial to highlight all of the text
between a pair of parenthesis. It's also really easy to text with
quotes surrounding it (strings).

#+BEGIN_SRC emacs-lisp
  (use-package expand-region
    :ensure t
    :commands er/expand-region
    :general
    ("C-=" 'er/expand-region))
#+END_SRC

*** Flycheck

In Node.js projects, I install ESLint as a dependency. Configure
Flycheck to use local ESLint.

#+BEGIN_SRC emacs-lisp
  (defun lia--use-eslint-from-node-modules ()
        "If exists, use local eslint. https://emacs.stackexchange.com/q/21205"
        (let* ((root (locate-dominating-file
                      (or (buffer-file-name) default-directory)
                      "node_modules"))
               (eslint (and root
                            (expand-file-name "node_modules/eslint/bin/eslint.js"
                                              root))))
          (when (and eslint (file-executable-p eslint))
            (setq-local flycheck-javascript-eslint-executable eslint))))
#+END_SRC

Flycheck enables syntax checking when programming. I don't know how
I'd live without it.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :ensure t
    :hook (prog-mode . flycheck-mode)
    :init
    (setq-default flycheck-disabled-checkers '(emacs-lisp-checkdoc))
    (add-hook 'flycheck-mode-hook #'lia--use-eslint-from-node-modules))
#+END_SRC

*** Format Code

With a quick keyboard shortcut, tidy up code in the current
buffer. Formatting typically requires another program to be
installed. JavaScript, for example, needs prettier to be installed.

#+BEGIN_SRC emacs-lisp
  (use-package format-all
    :ensure t
    :commands format-all-buffer
    :general
    ("C-c f" 'format-all-buffer))
#+END_SRC

*** Magit Is Magic

If you're reading this you probably know what Magit already is.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :ensure t
    :defer t
    :general
    ("C-x g" 'magit-status))
#+END_SRC

*** Project Management With Projectile

Projectile automatically detects some directories as
projects. Projectile provides ways to quickly find files in a project,
search in a project with grep/ag, etc.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :ensure t
    :defer t
    :general
    ("C-c p" '(:keymap projectile-command-map :package projectile))
    :init
    ;; (setq projectile-enable-caching t)
    (setq projectile-keymap-prefix (kbd "C-c p"))
    (setq projectile-completion-system 'ivy)
    :config
    (dolist (directory '("elpa" "node_modules" "vendor"))
      (add-to-list 'projectile-globally-ignored-directories directory)))
#+END_SRC

Provide more Ivy support for Projectile. It replaces some Projectile
commands with =counsel-projectile= alternatives.

#+BEGIN_SRC emacs-lisp
  (use-package counsel-projectile
    :ensure t
    :after projectile
    :config
    (counsel-projectile-mode))
#+END_SRC

*** Multiple Cursors

Multiple cursor support.

#+BEGIN_SRC emacs-lisp
  (use-package multiple-cursors
    :ensure t
    :general
    ("C->" 'mc/mark-next-like-this
     "C-<" 'mc/mark-previous-like-this
     "C-c C-<" 'mc/mark-all-like-this))
#+END_SRC

*** Better Undo with =undo-tree=

Default undo behaviour is too weird for me. Undo tree treats undo
history in a more conventional way but it still keeps all edits by
storing changes in a tree.

#+BEGIN_SRC emacs-lisp
  (use-package undo-tree
    :ensure t
    :general
    ("C-c u" 'undo-tree-visualize)
    :hook ((prog-mode . undo-tree-mode)
           (org-mode . undo-tree-mode)))
#+END_SRC

*** Install =wgrep= For Refactoring

Refactoring variables and functions is made easy with
=ivy-occur=. When searching for a string (with =swiper= or
=counsel-projectile-ag=, for example), pressing =C-c C-o= will bring a
buffer to edit the search results.

Editing the =ivy-occur= buffer requires =wgrep=.

#+BEGIN_SRC emacs-lisp
  (use-package wgrep
    :ensure t
    :hook ivy-occur-mode)
#+END_SRC

*** Templates/Snippets

Type abbreviations and expand them into code templates. Snippets are
located in =.emacs.d/snippets=.

#+BEGIN_SRC emacs-lisp
  (use-package yasnippet
    :ensure t
    :hook (after-init . yas-global-mode))
#+END_SRC

*** Smart Pairing of Delimitors

Insert, wrap, and delete parenthesis, quotes, and brackets.

#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :ensure t
    :hook (prog-mode . smartparens-mode)
    :general
    ("C-M-f" 'sp-forward-sexp
     "C-M-b" 'sp-backward-sexp
     "M-=" 'sp-rewrap-sexp
     "M-<backspace>" 'sp-splice-sexp)
    :config
    (require 'smartparens-config))
#+END_SRC

** Programming Languages + File Types

This section adds support for several programming languages and other
file types (JSON, Markdown, etc).

*** C/C++

Default switch/case indentation style:

#+BEGIN_SRC C
  switch (str) {
  case "foo":
    // ...
  case "bar":
    // ...
  }
#+END_SRC

I like to indent the body inside the braces like this:

#+BEGIN_SRC C
  switch (str) {
    case "foo":
      // ...
    case "bar":
      // ...
  }
#+END_SRC

Set =case= to be indented in switch/case.

#+BEGIN_SRC emacs-lisp
  (c-set-offset 'case-label '+)
#+END_SRC

Use IDE features for CMake projects.

#+BEGIN_SRC emacs-lisp
  (use-package cmake-ide
    :ensure t
    :defer t
    :init
    (setq cmake-ide-build-dir "build")
    (advice-add 'c-mode :before 'cmake-ide-setup))
#+END_SRC

*** Elm

Language support for Elm.

#+BEGIN_SRC emacs-lisp
  (use-package elm-mode
    :ensure t
    :mode "\\.elm\\'")
#+END_SRC

*** Haskell

Language support for Haskell.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :ensure t
    :mode "\\.hs\\'"
    :init
    (setq haskell-process-type 'stack-ghci)
    (setq-default haskell-indentation-layout-offset     lia-indent-width
                  haskell-indentation-starter-offset    lia-indent-width
                  haskell-indentation-left-offset       lia-indent-width
                  haskell-indentation-ifte-offset       lia-indent-width
                  haskell-indentation-where-pre-offset  lia-indent-width
                  haskell-indentation-where-post-offset lia-indent-width))
#+END_SRC

=haskell-mode= does not play well with Flycheck by itself. Install
=flycheck-haskell= for proper syntax checking.

#+BEGIN_SRC emacs-lisp
  (use-package flycheck-haskell
    :ensure t
    :hook (haskell-mode . flycheck-haskell-setup))
#+END_SRC

*** JavaScript

Language support for JavaScript.

Disable all warnings and errors shown by =js2-mode=. Instead, Flycheck
and ESLint is used to check for errors.

#+BEGIN_SRC emacs-lisp
  (use-package js2-mode
    :ensure t
    :mode "\\.js\\'"
    :hook (js2-mode . js2-imenu-extras-mode)
    :init
    (setq js2-strict-missing-semi-warning nil
          js2-missing-semi-one-line-override nil
          js2-mode-show-parse-errors nil
          js2-mode-show-strict-warnings nil))
#+END_SRC

=rjsx-mode= adds JSX/React support.

Setting =emmet-expand-jsx-className?= will use =className= instead of
=class= when expanding an Emmet abbreviation.

#+BEGIN_SRC emacs-lisp
  (use-package rjsx-mode
    :ensure t
    :mode "\\.jsx\\'"
    :magic ("/\\*\\* @jsx React\\.DOM \\*/" "^import React")
    :hook (rjsx-mode . (lambda ()
                         (setq emmet-expand-jsx-className? t))))
#+END_SRC

*** JSON

Add support for JSON files.

#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :ensure t
    :mode "\\.json\\'")
#+END_SRC

*** Markdown

Add support for Markdown.

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :ensure t
    :mode (".md\\'" "\\.md\\'" "\\.markdown\\'"))
#+END_SRC

*** Org Mode

Org mode configuration.

Add bindings to the agenda view. Require =org-habit= to enable habits
in the agenda view. Add markdown as one of the export options.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :defer t
    :general
    ([remap org-delete-indentation] 'lia/join-line)
    :config
    (require 'org-habit)
    (add-to-list 'org-export-backends 'md))
#+END_SRC

Set the directory to search for Org files.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/org/")
#+END_SRC

Add the files in =org-directory= for use in the agenda.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files (list org-directory))
#+END_SRC

Create an agenda view that lists all unscheduled tasks at the top, and
an overview of the week below.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-custom-commands
        '(("c" "My agenda"
           ((agenda "")
            (alltodo ""
                     ((org-agenda-skip-function
                       '(org-agenda-skip-entry-if
                         'todo 'done 'scheduled 'deadline))
                      (org-agenda-overriding-header "Unscheduled tasks"))))
           ((org-agenda-compact-blocks t)))))
#+END_SRC

Use 12-hour clock in the agenda view.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-timegrid-use-ampm t)
#+END_SRC

Resize the consistency graph in the agenda. Move it to the right and
display the last two weeks.

#+BEGIN_SRC emacs-lisp
  (setq org-habit-graph-column 56
        org-habit-following-days 1
        org-habit-preceding-days 14)
#+END_SRC

*** =restclient=

=restclient= is a tool to test web APIs. I use this package over
Postman. It's great.

#+BEGIN_SRC emacs-lisp
  (use-package restclient
    :ensure t
    :mode "\\.http\\'"
    :general
    (restclient-mode-map
     [remap eval-last-sexp] 'restclient-http-send-current-stay-in-window))
#+END_SRC

*** Rust

Language support for Rust.

#+BEGIN_SRC emacs-lisp
  (use-package rust-mode
    :ensure t
    :mode "\\.rs\\'")
#+END_SRC

*** YAML

Add support for YAML.

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.yaml\\'")
#+END_SRC

*** Web Mode

=web-mode.el= add support for editing web templates.

It's crazy powerful. I think it shines the best when working with a
file with mixed HTML, CSS, JS, and PHP.

#+BEGIN_SRC emacs-lisp
  (use-package web-mode
    :ensure t
    :init
    (setq-default web-mode-enable-auto-pairing  nil
                  web-mode-markup-indent-offset lia-indent-width
                  web-mode-css-indent-offset    lia-indent-width
                  web-mode-code-indent-offset   lia-indent-width
                  web-mode-script-padding       lia-indent-width
                  web-mode-style-padding        lia-indent-width)
    :mode (("\\.php\\'"  . web-mode)
           ("\\.html\\'" . web-mode)
           ("\\.ejs\\'"  . web-mode)
           ("\\.twig\\'" . web-mode)
           ("\\.vue\\'"  . (lambda ()
                             (web-mode)
                             (setq web-mode-style-padding 0
                                   web-mode-script-padding 0)))))
#+END_SRC

** Global Functions

I change my Emacs config a lot. Make it trivial to find my config.

#+BEGIN_SRC emacs-lisp
  (defun lia/open-config ()
    "Open Emacs config."
    (interactive)
    (find-file (expand-file-name "config.org" user-emacs-directory)))
#+END_SRC

-----

My workflow consists of two programs: Emacs, and the scratchpad
terminal running a tmux session.

This function creates a new tmux window and changes the focus from
Emacs to the scratchpad terminal. The working directory in the new
tmux window is the same as the one in Emacs.

#+BEGIN_SRC emacs-lisp
  (defun lia/new-tmux-window-and-launch-scratchpad ()
    "Create a new tmux window and focus the scratchpad terminal."
    (interactive)
    (when (zerop (shell-command
                  (format "tmux new-window -c '%s'"
                          (expand-file-name default-directory))))
      (call-process-shell-command "~/scripts/scratchpad.sh" nil 0)))
#+END_SRC

-----

I prefer to use a file explorer over something like =ranger= or
=dired=.

Open the current working directory in an external file explorer. This
is better than something like =:!thunar= because this happens
asynchronously (Emacs doesn't wait for Thunar to exit).

"But can't you use =:!thunar &= or run =async-shell-command=?"

Sure, but the solution below doesn't display a new buffer. Both
=:!thunar &= and =async-shell-command= pops open a buffer for showing
the command output. I'm not interested in that.

#+BEGIN_SRC emacs-lisp
  (defun lia/open-file-explorer ()
    "Open file explorer in current directory."
    (interactive)
    (call-process-shell-command "~/scripts/files.sh ." nil 0))
#+END_SRC

-----

Go to =index.org= located in the the =org-directory=.

#+BEGIN_SRC emacs-lisp
  (defun lia/goto-org-index-file ()
    "Navigate to my `index.org' file."
    (interactive)
    (if (bound-and-true-p org-directory)
        (find-file (expand-file-name "index.org" org-directory))
      (message "`org-directory' not set.")))
#+END_SRC

-----

Open my custom agenda directly. Don't go through the dispatch menu.

#+BEGIN_SRC emacs-lisp
  (defun lia/org-agenda ()
    (interactive)
    (org-agenda nil "c"))
#+END_SRC

-----

Other programs handle certain file types better than Emacs (images and
PDFs for example). This function makes it easy to handle the current
file.

#+BEGIN_SRC emacs-lisp
  (defun lia/open ()
    "Open current file (or selected file if in dired mode) in an external program."
    (interactive)
    (call-process "xdg-open" nil 0 nil
                  (if (eq major-mode 'dired-mode)
                      (dired-get-file-for-visit)
                    buffer-file-name)))
#+END_SRC

-----

Toggle between absolute line numbers and (visual) relative line numbers.

Absolute line numbers are lines that are labelled as is. Line 1 is
labelled =1=, Line 2 is labelled =2=, etc.

#+BEGIN_EXAMPLE
  29  ...
  30  Roses.are("Red");
  31  Violets.are("Blue");
  32  throw new Error();
  33  // on line 32
  34  ...
#+END_EXAMPLE

Relative line numbers label the lines based on the cursor
location. The line below the cursor is label =1=, the line below that
is labelled =2=, etc, and vice versa. The line with the cursor is
labelled as is.

#+BEGIN_EXAMPLE
   3  ...
   2  Roses.are("Red");
   1  Violets.are("Blue");
  32  throw new Error(); // cursor on this line
   1  // on line 32
   2  ...
#+END_EXAMPLE

=visual= line numbers type is the same as relative, except it
disregards hidden lines (for example, when folding).

#+BEGIN_SRC emacs-lisp
  (defun lia/toggle-display-line-number-type ()
    "Toggle the line number type between absolute and (visual) relative."
    (interactive)
    (setq display-line-numbers-type
          (if (eq display-line-numbers-type 'visual)
              (progn (message "Line number type: absolute") t)
            (progn (message "Line number type: visual") 'visual)))
    ;; update line numbers if it's currently being displayed
    (when (bound-and-true-p display-line-numbers-mode)
      (display-line-numbers--turn-on)))
#+END_SRC

-----

Maximize/minimize a window. Maximizing fills the current window and
removes all other windows. Minimizing restores the windows that were
previously removed.

#+BEGIN_SRC emacs-lisp
  (defun lia/toggle-other-windows ()
    "Make a window fill the frame, or restore previous windows."
    (interactive)
    (if (= 1 (length (window-list)))
        (if (bound-and-true-p lia--saved-window-configuration)
            (progn
              (setq lia--saved-buffer (current-buffer))
              (set-window-configuration lia--saved-window-configuration)
              (switch-to-buffer lia--saved-buffer))
          (message "Only one window"))
      (setq lia--saved-window-configuration (current-window-configuration))
      (delete-other-windows)))
#+END_SRC

-----

Move point to begining of line or first character on a line. [[https://emacsredux.com/blog/2013/05/22/smarter-navigation-to-the-beginning-of-a-line/][Stolen here]].

#+BEGIN_SRC emacs-lisp
  (defun lia/smarter-move-beginning-of-line (arg)
    "Move point back to indentation of beginning of line.

  Move point to the first non-whitespace character on this line.
  If point is already there, move to the beginning of the line.
  Effectively toggle between the first non-whitespace character and
  the beginning of the line.

  If ARG is not nil or 1, move forward ARG - 1 lines first.  If
  point reaches the beginning or end of the buffer, stop there."
    (interactive "^p")
    (setq arg (or arg 1))

    ;; Move lines first
    (when (/= arg 1)
      (let ((line-move-visual nil))
        (forward-line (1- arg))))

    (let ((orig-point (point)))
      (back-to-indentation)
      (when (= orig-point (point))
        (move-beginning-of-line 1))))
#+END_SRC

-----

Sensible =delete-indentation=.

#+BEGIN_SRC emacs-lisp
  (defun lia/join-line (n)
    "Join N lines.
  If there is a region active, join lines in the region instead."
    (interactive "p")
      (if (use-region-p)
        (let ((fill-column (point-max)))
          (fill-region (region-beginning) (region-end)))
        (dotimes (_ (abs n))
          (delete-indentation (natnump n)))))
#+END_SRC

** Settings

*** Indentation

Enable/disable tabs for indentation.

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode lia-use-tabs)
#+END_SRC

Change the indentation size for some major modes. Indentation size for
other modes (like =haskell-mode=) is set in its =use-package=
declaration.

#+BEGIN_SRC emacs-lisp
  (setq-default tab-width               lia-indent-width
                c-basic-offset          lia-indent-width
                sh-basic-offset         lia-indent-width
                javascript-indent-level lia-indent-width
                js-indent-level         lia-indent-width
                js-switch-indent-offset lia-indent-width
                css-indent-offset       lia-indent-width)
#+END_SRC

*** Backup Files

Move backup~ files to a =backups= folder in the Emacs directory.

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `((".*" . ,(concat user-emacs-directory "backups"))))
#+END_SRC

I find the #autosave# files annoying. Don't use them.

#+BEGIN_SRC emacs-lisp
  (setq auto-save-default nil)
#+END_SRC

I also don't want .#lock files.

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

*** Scrolling

Change the mouse scroll behaviour.

A few people use my Emacs configuration because I hand over my laptop
to them for code review. These changes are nice because they use the mouse.

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-scroll-amount '(2 ((shift) . 1)) ;; one/two line at a time
        mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
        mouse-wheel-follow-mouse 't) ;; scroll window under mouse
#+END_SRC

Set "smooth scrolling". When moving towards the up/bottom of the
buffer, don't jump down half of the view. Instead, scroll one line at
a time.

#+BEGIN_SRC emacs-lisp
  (setq scroll-step 1
        scroll-conservatively 1000)
#+END_SRC

*** Other Settings

Don't delay showing unfinished key commands. Can't be set to 0,
because the keys won't be displayed at all. Set the delay to a very
low number.

#+BEGIN_SRC emacs-lisp
  (setq echo-keystrokes 0.02)
#+END_SRC

Show column number in the modebar

#+BEGIN_SRC emacs-lisp
  (setq column-number-mode t)
#+END_SRC

Let backspace simply delete a character.

"Wait, that's what backspace does, right?"

Not exactly. If the cursor is in front of a tab character and the user
hits backspace, the tab character gets converted to spaces, then a
space character is deleted.

In my opinion, that behaviour is dumb. Just delete a single
character. Simple.

#+BEGIN_SRC emacs-lisp
  (setq backward-delete-char-untabify-method nil)
#+END_SRC

Guess target directory when copying/moving files in dired.

This emulates drag and drop functionality with two dired windows in a
split.

#+BEGIN_SRC emacs-lisp
  (setq dired-dwim-target t)
#+END_SRC

When deleting files, don't actually delete them. Move them to the
trash instead.

#+BEGIN_SRC emacs-lisp
  (setq delete-by-moving-to-trash t)
#+END_SRC

You can view HTML quickly with =C-c C-v= in HTML buffers. Set the
command to launch Firefox.

#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function 'browse-url-firefox)
#+END_SRC

I sometimes use Ubuntu. In Ubuntu, Emacs will use the annoying alert
sound for certain actions. Disable it.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

Change yes/no prompts to be y/n. Saves a bit of typing.

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Automatically revert buffers when they change on disk. This is handy
when running =npm install= and =package.json= gets updated.

#+BEGIN_SRC emacs-lisp
  (global-auto-revert-mode t)
#+END_SRC

Sensible region behaviour. When a region is active, any text inserted
will be overwritten.

#+BEGIN_SRC emacs-lisp
  (delete-selection-mode 1)
#+END_SRC

** Late Initialization

Garbage collection was avoided by setting the memory threshold to a
large value. =file-name-handler-alist= was unset to avoid extra checks
when opening files. These things were done to increase startup speed.

This is near the end of the config. Reset the garbage collector and
file name handler.

#+BEGIN_SRC emacs-lisp
  (setq gc-cons-threshold 16777216
        gc-cons-percentage 0.1
        file-name-handler-alist lia--file-name-handler-alist)
#+END_SRC

We're done! At the end of startup, show the startup time and the total
number of garbage collections.

#+BEGIN_SRC emacs-lisp
  (defun display-startup-echo-area-message ()
    (message
     (format "Started up in %.2f seconds with %d garbage collections."
             (float-time (time-subtract after-init-time before-init-time))
             gcs-done)))
#+END_SRC
